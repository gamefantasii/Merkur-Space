workflows:
  unity-ios:
    name: Unity iOS (Pro serial fallback)
    environment:
      groups:
        - unity_credentials            # UNITY_EMAIL, UNITY_PASSWORD, UNITY_SERIAL
        - app_store_credentials        # APP_STORE_CONNECT_ISSUER_ID, APP_STORE_CONNECT_KEY_IDENTIFIER, APP_STORE_CONNECT_PRIVATE_KEY
        - certificate_credentials      # CERTIFICATE_PRIVATE_KEY (+ опц. CERTIFICATE_PASSWORD)
      vars:
        UNITY_PROJECT_PATH: "ASO iOs 8 Merkur Space"   # подпапка проекта (с пробелами)
        IOS_EXPORT_PATH: "$CM_BUILD_DIR/build/ios"
        XCODE_WORKSPACE: "Unity-iPhone.xcworkspace"
        XCODE_PROJECT: "Unity-iPhone.xcodeproj"
        XCODE_SCHEME: "Unity-iPhone"
        BUNDLE_ID: "com.joams.merspace"
        NSE_BUNDLE_ID: "com.joams.merspace.OneSignalNotificationServiceExtension"
        APP_STORE_APPLE_ID: "6751573211"
      xcode: 16.4
      cocoapods: default

    scripts:
      - name: Detect Unity version from ProjectVersion.txt
        script: |
          set -e
          PV="$UNITY_PROJECT_PATH/ProjectSettings/ProjectVersion.txt"
          [ -f "$PV" ] || { echo "No ProjectVersion.txt at $PV"; exit 1; }
          REQ_VER="$(sed -n 's/^m_EditorVersion:[[:space:]]*//p' "$PV" | head -n1)"
          [ -n "$REQ_VER" ] || { echo "Cannot parse Unity version"; exit 1; }
          echo "UNITY_VERSION=$REQ_VER" | tee -a "$CM_ENV"
          echo "UNITY_HOME=/Applications/Unity/Hub/Editor/$REQ_VER/Unity.app" | tee -a "$CM_ENV"
          echo "IOS_EXPORT_PATH=$IOS_EXPORT_PATH" | tee -a "$CM_ENV"
          mkdir -p "$IOS_EXPORT_PATH"

      - name: Install Unity (only if missing)
        script: |
          set -e
          if [ -x "$UNITY_HOME/Contents/MacOS/Unity" ]; then
            "$UNITY_HOME/Contents/MacOS/Unity" -version
            exit 0
          fi
          if ! command -v unity-hub >/dev/null 2>&1; then
            brew install --cask unity-hub || true
          fi
          unity-hub install --version "$UNITY_VERSION" --module iOS || true
          [ -x "$UNITY_HOME/Contents/MacOS/Unity" ] || { echo "Unity not found at $UNITY_HOME"; exit 1; }
          "$UNITY_HOME/Contents/MacOS/Unity" -version

      - name: Activate Unity (login, fallback to serial)
        script: |
          set -e
          if "$UNITY_HOME/Contents/MacOS/Unity" -batchmode -nographics -quit -logFile - \
               -username "${UNITY_EMAIL}" -password "${UNITY_PASSWORD}"; then
            echo "Activated via sign-in."
          elif [ -n "${UNITY_SERIAL:-}" ]; then
            "$UNITY_HOME/Contents/MacOS/Unity" -batchmode -nographics -quit -logFile - \
              -serial "${UNITY_SERIAL}" -username "${UNITY_EMAIL}" -password "${UNITY_PASSWORD}"
            echo "Activated via serial."
          else
            echo "No valid Unity license (need UNITY_SERIAL or sign-in)." && exit 1
          fi

      - name: Ensure BuildScript exists
        script: |
          set -e
          mkdir -p "$UNITY_PROJECT_PATH/Assets/Editor"
          FILE="$UNITY_PROJECT_PATH/Assets/Editor/Build.cs"
          if [ ! -f "$FILE" ]; then
            cat > "$FILE" <<'CSHARP'
// Assets/Editor/Build.cs (autogenerated)
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEditor.Build.Reporting;

public static class BuildScript
{
    public static void BuildiOS()
    {
        var exportPath = Environment.GetEnvironmentVariable("IOS_EXPORT_PATH");
        if (string.IsNullOrEmpty(exportPath)) exportPath = "build/ios";

        TryForceResolve();

        var scenes = EditorBuildSettings.scenes.Where(s => s.enabled).Select(s => s.path).ToArray();
        if (scenes.Length == 0)
        {
            scenes = AssetDatabase.GetAllAssetPaths().Where(p => p.EndsWith(".unity", StringComparison.OrdinalIgnoreCase)).ToArray();
            if (scenes.Length == 0) throw new Exception("No scenes found. Add scenes to Build Settings.");
        }

        if (Directory.Exists(exportPath)) Directory.Delete(exportPath, true);
        Directory.CreateDirectory(exportPath);

        var opts = new BuildPlayerOptions {
            scenes = scenes,
            locationPathName = exportPath,
            target = BuildTarget.iOS,
            options = BuildOptions.None
        };

        var report = BuildPipeline.BuildPlayer(opts);
        if (report.summary.result != BuildResult.Succeeded)
            throw new Exception($"iOS build failed: {report.summary.result}");
        UnityEngine.Debug.Log("[BuildScript] Exported Xcode project to: " + exportPath);
    }

    static void TryForceResolve()
    {
        try {
            var iosResolver = Type.GetType("Google.IOSResolver, Google.IOSResolver", false);
            var resolverProp = iosResolver?.GetProperty("Resolver", BindingFlags.Public | BindingFlags.Static);
            var resolver = resolverProp?.GetValue(null);
            var force = resolver?.GetType().GetMethod("ForceResolve", BindingFlags.Public | BindingFlags.Instance);
            force?.Invoke(resolver, null);
        } catch {}

        try {
            var t = Type.GetType("GooglePlayServices.PlayServicesResolver, Google.JarResolver", false)
                 ?? Type.GetType("GooglePlayServices.PlayServicesResolver, ExternalDependencyManager", false);
            var m = t?.GetMethod("DoResolution", BindingFlags.Public | BindingFlags.Static);
            m?.Invoke(null, null);
        } catch {}
    }
}
CSHARP
            echo "Injected $FILE"
          else
            echo "Build.cs exists."
          fi

      - name: Export iOS project
        script: |
          set -e
          "$UNITY_HOME/Contents/MacOS/Unity" -batchmode -nographics -quit -logFile - \
            -projectPath "$UNITY_PROJECT_PATH" -executeMethod BuildScript.BuildiOS
          /bin/ls -la "$IOS_EXPORT_PATH" || true

      - name: Install CocoaPods
        script: |
          set -e
          cd "$IOS_EXPORT_PATH"
          [ -f "Podfile" ] || { echo "Podfile not found. Run EDM4U iOS Resolver in Unity and commit plugin updates."; exit 1; }
          pod repo update || true
          pod install

      - name: Keychain & signing files (App + NSE)
        script: |
          set -e
          keychain initialize
          app-store-connect fetch-signing-files "$BUNDLE_ID" \
            --type IOS_APP_STORE --platform IOS --create \
            --certificate-key @env:CERTIFICATE_PRIVATE_KEY ${CERTIFICATE_PASSWORD:+--certificate-key-password "$CERTIFICATE_PASSWORD"}
          app-store-connect fetch-signing-files "$NSE_BUNDLE_ID" \
            --type IOS_APP_STORE --platform IOS --create \
            --certificate-key @env:CERTIFICATE_PRIVATE_KEY ${CERTIFICATE_PASSWORD:+--certificate-key-password "$CERTIFICATE_PASSWORD"}
          keychain add-certificates

      - name: Apply provisioning to Xcode project
        script: |
          set -e
          cd "$IOS_EXPORT_PATH"
          xcode-project use-profiles

      - name: Increment build number
        script: |
          set -e
          LATEST=$(app-store-connect get-latest-testflight-build-number "$APP_STORE_APPLE_ID" || echo 0)
          cd "$IOS_EXPORT_PATH"
          agvtool new-version -all $((LATEST + 1))

      - name: Build IPA
        script: |
          set -e
          cd "$IOS_EXPORT_PATH"
          if [ -d "$XCODE_WORKSPACE" ]; then
            xcode-project build-ipa --workspace "$XCODE_WORKSPACE" --scheme "$XCODE_SCHEME"
          else
            xcode-project build-ipa --project "$XCODE_PROJECT" --scheme "$XCODE_SCHEME"
          fi

      - name: Deactivate Unity license
        script: |
          "$UNITY_HOME/Contents/MacOS/Unity" -batchmode -quit -returnlicense -nographics || true

    artifacts:
      - "$IOS_EXPORT_PATH/*.ipa"
      - "$HOME/Library/Developer/Xcode/DerivedData/**/Build/**/*.dSYM"

    publishing:
      app_store_connect:
        api_key: $APP_STORE_CONNECT_PRIVATE_KEY
        key_id: $APP_STORE_CONNECT_KEY_IDENTIFIER
        issuer_id: $APP_STORE_CONNECT_ISSUER_ID
        submit_to_testflight: true
